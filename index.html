<!DOCTYPE html>
<html>
  <head>
  <style>
  table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
  }
  th, td {
    padding: 5px;
    text-align: left;    
  }
</style>
  </head>
<body>

<h1>Lenguajes y Automatas II</h1>
  
<h2>Forma de Evaluacion</h1>

<table>
  <tr>
    <th  colspan="2">Forma de Evaluación</th>
  </tr>
  <tr>
    <th>Actividad</th>
    <th>Puntos Max.</th>
  </tr>
  <tr>
    <td>Actividad 1</td>
    <td>20</td>
  </tr>
  <tr>
    <td>Actividad 2</td>
    <td>20</td>
  </tr>
  <tr>
    <td>Actividad 3</td>
    <td>20</td>
  </tr>
  <tr>
    <td>Actividad 4</td>
    <td>20</td>
  </tr>
  <tr>
    <td>Proyecto Final</td>
    <td>30</td>
  </tr>
  <tr>
    <td>Exposicion de tema</td>
    <td>15</td>
  </tr>
  <tr>
    <td>Examen</td>
    <td>15</td>
  </tr>
</table>
<h2>Notas</h2>

<ol>
  <li>Los proyectos del 1-4 corresponden a cada unidad, en el cual se realizara una actividad codificada en
algún lenguaje de programación para cubrir aspectos de la unidad en curso, se deberá subir a un
repositorio el código generado y entregar un reporte en PDF para tener derecho a una evaluación.</li>
  <li>El proyecto integrador al igual que los proyectos anteriores constara de un reporte y código,
obviamente sera mas complejo que los anteriores.</li>
  <li>Se debe participar en la exposición de un subtema al menos, de lo contrario serán 10 puntos menos
sobre la calificación final.</li>
  <li>Los puntos de la exposición de un subtema están sujetos a la realización de los proyectos, es decir
para tener los puntos de una presentación deben haber entregado por lo menos 3 proyectos.</li>
  <li>El presentar un examen es “opcional”, dependerá del desempeño individual del alumno, si el alumno
tiene una calificación aprobatoria y esta conforme con ella puede omitir el examen, si no tiene una
calificación aprobatoria deberá presentar el examen y aprobarlo.</li>
  <li>La cantidad de putos obtenidos por cada actividad mencionada anteriormente dependerá de la
calidad de la actividad y de si se cumplió o no con lo requisitos preestablecidos para cada una de ellas.</li>
</ol>   

<h2>Material Extra</h2>
<ol>
  <li> <a href="#"> Complejidad Computacional </a></li>
  <li> <a href="#"> Latex </a></li>
  <li> <a href="#"> Recordatorio de Lenguajes y Automatas I </a></li>
  <li> <a href="#"> punto4 </a></li>
  <li> <a href="#"> punto5 </a></li>
  <li> <a href="#"> punto6 </a></li>
  <li> <a href="#"> punto7 </a></li>
</ol> 

  
<h2>Proyectos</h2>
<ol>
  <li> <a href="proyecto1.html"> Arbol de Expresiones </a></li>
  <li> <a href="#"> Actividad 2 </a></li>
  <li> <a href="#"> Actividad 3 </a></li>
  <li> <a href="#"> Actividad 4 </a></li>
  <li> <a href="#"> Actividad 4 </a></li>
  <li> <a href="evaluacion.html"> Calificaciones </a></li>
  <li> <a href="#"> Bibliografia </a></li>
</ol> 

  <h2>Recordatorio de Lenguajes y Automatas I</h2>
    <h3>Comprobacion de Tipos</h3>
    <h4>¿Que es un compilador?</h4>
    <h4>Partes de un comppilador</h4>
  <h2>Complejidad Computacional</h2>
  
  <h2>Arboles de Expresiones</h2>
  <h4>¿Que es un arbol de Expresiones?</h4>
  <p>Un árbol de expresiones es un tipo de árbol binario en el que se pueden
representar operaciones, se suelen utilizar en la representación de
operaciones en memoria usualmente en compiladores.</p>
  <h4>Caracteristicas</h4>
  <ul>
  <li> Las raíces siempre son operadores</li>
  <li> Las hojas siempre son operandos</li>
  <li> Si un operador tiene mayor prioridad que la raíz, se coloca como hijo</li>
  <li> Si tiene igual o menor prioridad se coloca como padre.</li>
  <li> Los paréntesis no se almacenan en el árbol pero se implican por la forma
del árbol</li>
</ul> 
  
    <h4>Recorridos</h4>
  <ul>
  <li> Preorden: Raíz, hijo izquierdo, hijo derecho</li>
  <li> Inorden: Hijo izquierdo, raíz, hijo derecho</li>
  <li> Postorden: Hijo izquierdo, hijo derecho, raíz</li>
  <li> Por niveles: Todos los nodos del nivel de izq a derecho</li>
</ul> 
  
  <h2>Partes Sintácticas de un analizador Semántico</h2>
  <h2>Comprobacion de Tipos</h2>
  <h2>Pila Semántica</h2>
  <h2>Esquema de Traducción</h2>
  <h2>Tabla de Simbolos</h2>
  <h2>Manejo de Errores Semánticos</h2>
  
  
  <h2>Bibliografia</h2>
  <ol>
  <li> Aho Alfred V., U. J. (2007). Compiladores. Principios, técnicas y herramientas (2da. ed.).
México: Pearson Educación.</li>
  <li> Alfonseca Moreno, M. (2006). Compiladores e intérpretes: teoría y práctica (1ra ed.). España:
Pearson/Prentice Hall.</li>
  <li> Carrión Viramontes, J. E. (2008). Teoría de la computación. México: Limusa.</li>
  <li> Hopcroft John E., M. R. (2002). Introducción a la Teoría de Autómatas, Lenguajes y
Computación (2da. ed.). Madrid: Addison-Wesley.</li>
  <li> Isasi Pedro, M. P. (1997). Lenguajes, gramáticas y autómatas. Un enfoque Práctico. Addison-
Wesley.</li>
  <li> Kelley, D. (1995). Teoría de Autómatas y Lenguajes Formales, (1ra. ed.). Madrid: Prentice Hall.</li>
  <li> Lemone, K. A. (1996). Fundamentos de compiladores: cómo traducir al lenguaje de
computadora. México D.F.: Compañía Editorial Continental.</li>
  <li> Martin, J. (2004). Lenguajes formales y teoría de la computación. México: McGraw-Hill /
Interamericana de México.</li>
  <li> Ruíz, J. (2009). Compiladores-Teoría e implementación. México: Alfaomega./li>
  <li> Grune, Dick. (2007). Diseño de compiladores modernos. McGraw-Hill.</li>
</ol> 

</body>
</html>
